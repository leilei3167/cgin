package framework

/*
代码的封装很重要,第4部分需要回顾之前的代码,看看如何通过封装进一步提高代码可拓展性
在业务controller中,创建了一个具有定时器功能的 Context，然后开启一个 Goroutine 执行正式的业务逻辑，
并且监听定时器和业务逻辑，哪个先完成，就先输出内容

从代码功能分析,由2部分组成:
1.业务逻辑:此处由sleep模拟,实际开发这里会有很重的业务代码
2.非业务逻辑:创建ctx,等待finish信号等,这部分是非常通用的功能,可能在多个控制器都会用到

因此,我们需要设计,将非业务代码抽象并封装,提供接口给控制器使用,这部分的实现就叫中间件

把核心业务逻辑封装起来,一层一层添加装饰,最终请求正序一层一层通过装饰器,进入核心处理模块,完成后再反序退出

*/

/*
中间件的实现:
	装饰器模式是逐层的,最自然想到函数嵌套
	对于中间件,我们要封装核心逻辑,也就是输入 要是一个控制器(ControllerHandler,输出也是)
timeout.go中将设置超时等逻辑剥离出来作为中间件,接收处理器和时间作为参数,利用函数回调执行
调用处代码就成了:
		core.Get("/user/login", framework.TimeoutHandler(UserLoginController, time.Second*10))
这种嵌套,使下层中间件是上层中间件的参数,通过一层层嵌套实现了中间件的装饰器模式

但这种形式有几个非常大的缺点:
	1.循环嵌套,中间件多了之后会很长
	2.只能为单个业务控制器设置,不能为某个组批量设置

*/

/*
Pipeline思想改造中间件:
	将每个控制器所需的中间件用数组连接,形成一条流水线,就能解决嵌套带来的问题,中间件不再以下一层的Controller
作为参数了,它只需要返回有自身逻辑的Controller

	但是这种方式,如何在回调函数中调用下一个控制器呢?回调函数中只有Context一个参数,很自然能够想到,我们在ctx中添加
相应的字段,因为中间件返回值和业务逻辑处理器是同类型,我们可以将其组合成数组,来表示某个路由的业务逻辑

	1.首先,需要修改存放处理器的节点node,将原先的单个处理器,修改为处理器数组(中间件组成的处理器链),这样在寻找路由节点时,
就能找到对应的控制器链路,节点存放整个调用链路

	2.修改Context的结构,在context中也需要保存调用链路数组,并且还要记录执行到了哪个控制器

	3.实现链调用方式
	- Context维护一个调用链和一个index,用于定位链路调用的位置
	- 为Context实现一个Next方法,每调用一次,就能使控制器链路向后移动一步,TODO:Next函数是中间件重点,要好好理解
	- 注意index的初始值应该为-1,这样才能保证第一次调用时值为0,即第一个控制器

	4.实现控制器链路的注册
	Group和Core两个结构需要增加注册中间件的入口:
	- Core和Group单独设计一个Use函数,为其数据结构负责的路由批量设置中间件
	- 为 Core 和 Group 注册单个路由的 Get / Post / Put / Delete 函数，设置中间件

*/

/*
最基本的Recover中间件

*/
